---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Methods {#sec-methods}

```{r, echo = FALSE, results = FALSE, message = FALSE, warning = FALSE}
#| label: set-chunk-options
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE)
library(skimr)
library(ggplot2)

targets::tar_load(c("ais_date_start",
                    "ais_date_end",
                    "spatial_resolution",
                    "temporal_resolution",
                    "squid_vessel_list",
                    #"gridded_time_effort_by_flag_summary",
                    #"sst_data_aggregated_summary",
                    "sst_data_aggregated_one_month_subset",
                    "sst_data_aggregated_time_series",
                    "joined_dataset_summary"))

source("r/functions.R")
```

## Data sources

### AIS-based Fishing effort

We use satellite-based individual vessel monitoring AIS data processed by Global Fishing Watch (@kroodsma2018tracking). We use the V3 pipeline table `pipe_ais_v3_published.messages`. Variables of interest within this table include the following
(descriptions are taken directly from the schema for
`pipe_ais_v3_published.messages`):

-   `ssvid`: source specific vessel id; MMSI for AIS
-   `hours`: time since the previous position in the segment
-   `timestamp`: timestamp for position
-   `lon`: longitude
-   `lat`: latitude
-   `night_loitering`: 1 if the seg_id of every message of a squid_jigger that is at night and not moving, 0 if not.

In order to minimize noisy data, we only include AIS messages that have
a `clean_segs` boolean (i.e., all messages must have `good_seg` boolean
and must not have an `overlapping_and_short` boolean). We filter to just those messages where `night_loitering = 1`. For squid jigging vessels, GFW uses the heuristic of night loitering to identify when they are fishing. Therefore, any `hours` where `night_loitering = 1` can be classified as `fishing_hours`

We take the raw high-resolution AIS data and aggregate `fishing_hours` spatially (by `r spatial_resolution`x`r spatial_resolution` degree pixels, which are roughly `r spatial_resolution*111`km x `r spatial_resolution*111`km at the equator), temporally by `r stringr::str_to_lower(temporal_resolution)`, and by flag. We currently process data from `r stringr::str_remove_all(ais_date_start,'\'')` through `r stringr::str_remove_all(ais_date_end,'\'')`.

### Vessel info

Vessel characteristics data processed are by Global Fishing Watch (@park2023tracking). We use the V3 pipeline table `pipe_ais_v3_published.vi_ssvid_v20240601`. Variables of interest within this table include the following
(descriptions are taken directly from the schema for
`pipe_ais_v3_published.vi_ssvid_v20240301`):

-   `ssvid`: source specific vessel id; MMSI for AIS
-   `best.flag`: best flag state (ISO3) for the vessel\
-   `best.best_vessel_class`: best vessel class for the vessel (using
    official registry information where available, or the GFW
    vessel characteristics algorithm where not available)
-   `best.best_engine_power_kw `: best engine power (kilowatts) for
    the vessel (using official registry information where available, or
    the GFW characteristics algorithm where not
    available)
-   `activity.active_hours`: hours the vessel was broadcasting AIS and moving more than 0.1 knots
-   `activity.offsetting`: true if this vessel has been seen with an offset postition at some point between 2012 and 2019
-   `activity.overlap_hours_multinames`: the total numbers of hours of overlap
    between two segments where, over the time period of the two segments
    that overlap (including the non-overlapping time of the segments),
    the vessel broadcast two or more normalized name, where each
    normalized name was bradcast at least 10 or more times. That is a
    bit complicated, but the goal is to identify overlapping segments
    where there were likely more than one identity. (this should be 0;
    if it is \> 0, it can be used as a filter to remove potentially
    erroneous/noisy vessels)
    
We filter to just those vessels where `best.best_vessel_class = squid_jigger`. Additionally, to reduce noise, we filter out vessels that broadcast exceedingly infrequently (i.e., `activitiy.active_hours < 24`) or are noisy/spoofing/offsetting vessels (i.e.,  `NOT activity.offsetting OR activity.overlap_hours_multinames > 0.`) They are simply not reliable and will not provide good effort estimates. This leaves us with `r prettyNum(nrow(squid_vessel_list), big.mark = ",")` squid vessels for our analysis.

### Sea surface temperature (SST)

Sea surface temperature (SST) data come from [NOAA's Optimum Interpolation Sea Surface Temperature (OISST) version 2.1](https://coastwatch.pfeg.noaa.gov/erddap/griddap/ncdcOisst21Agg.html) (@huang2021improvements), which were downloaded from their Coast Watch ERDDAP server. The raw data are provided globally at 0.25x0.25 degree daily resolution. We aggregate the data to `r spatial_resolution`x`r spatial_resolution` degree monthly resolution by calculating the mean, standard deviation, minimum, and maximum SST for each `r spatial_resolution`x`r spatial_resolution` degree pixel and month.

We can look at a map of SST, using August 2024 as an example (@fig-sst-map).

```{r}
#| label: fig-sst-map
#| fig-cap: Map of mean sea surface temperature in August 2024, using 0.5x0.5 degree pixels.

land <- rnaturalearth::ne_countries(returnclass = "sf")

ggplot() +
  geom_tile(data = sst_data_aggregated_one_month_subset,
            aes(fill = mean_sst,
                x = lon_bin,
                y = lat_bin)) +
  geom_sf(data = land,
          color = "#374a6d",
          fill = "#374a6d") +
  scale_fill_viridis_c("Mean sea surface temperature (degrees C)",
                       option = "inferno",
                       na.value = "black") +
  labs(x = '',
       y= '') +
  theme_map() +
  guides(fill = guide_colorbar(title.position = "top",
                               title.hjust = 0.5,
                               frame.colour = "black",
                               ticks.colour = "black",
                               barwidth = unit(12, "cm"),
                               barheight = unit(1, "cm"))) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))
```

Aggregating across the mean sea surface temperatures of each pixel, we can calculate the mean global sea surface temperature over time (@fig-sst-time-series). This allows us to see both seasonal trends, and what appears to be a generally increasing trend over time.

```{r}
#| label: fig-sst-time-series
#| fig-cap: Time series of global mean sea surface temperature.

sst_data_aggregated_time_series |>
  ggplot(aes(x = time, y = mean_sst)) +
  geom_line() +
  theme_plot() +
  labs(x = "",
       y = "Mean global sea surface temperature\n(degrees C)")
```

### Night light detections using VIIRS (Visible Infrared Imaging Radiometer Suite)

We use the NOAA VIIRS (Visible Infrared Imaging Radiometer Suite) data product to detect night light emissions from vessels. When the appropriate radiance threshold is applied, these can generally be assumed to represent light-luring squid vessels. Since use only the single most accurate VIIRS detection measurements each day, these can also be thought of as representing a fishing effort metric of vessel-days. We use the VIIRS data as an alternative fishing effort metric to AIS-based fishing effort since AIS is not used on all vessels, and since it can also be disabled on the vessels that do use it.

We leverage the VIIRS boat detection dataset developed by @elvidge2015automatic. We then apply similar processing as @seto2023fishing, which includes the following steps:

- Reduce false detections near South America caused by the the South Atlantic Anomaly (an abundance of high-energy particles in the atmosphere). 
- Use a same radiance threshold of 10 nW cm−2 sr−1 used by @seto2023fishing (and established by @park2020illuminating) in order to filter detections to those likely engaged in in pelagic light-luring activity. 
- To eliminate double-counting when there may be multiple satellite overpasses on a single night, only count detections from the overpass with the smallest satellite zenith angle (smaller zenith angles are more accurate)

We then finally aggregate the total detections for each `r spatial_resolution`x`r spatial_resolution` degree pixel and month. 

We can compare AIS-based fishing effort with VIIRS detections by aggregating AIS effort across flags for each month and pixel, and then matching this with VIIRS detections by month and pixel. There appears to be a generally strong relationship between the two, although there are many outliers that appear to have very low AIS-based fishing effort but actually have a very high number of VIIRS detections.

```{r}
#| label: fig-ais-viirs-comparison
#| fig-cap: Comparison of AIS-based fishing effort (x-axis) and VIIRS detections (y-axis) for each pixel and month.

targets::tar_load(gridded_time_effort_by_flag)
targets::tar_load(gridded_viirs_detections)

gridded_time_effort <- gridded_time_effort_by_flag |>
  dplyr::group_by(month,lon_bin,lat_bin) |>
  dplyr::summarize(fishing_kw_hours = sum(fishing_kw_hours,na.rm=TRUE)) |>
  dplyr::ungroup()

ais_viirs_comparison_data <- gridded_time_effort |>
  dplyr::inner_join(gridded_viirs_detections,
              by=c("month","lon_bin","lat_bin")) 

ais_viirs_comparison_data |>
  ggplot(aes(x = fishing_kw_hours,
             y = viirs_detections)) +
  geom_point() +
  theme_plot() +
  labs(x = "AIS-based fishing effort (kW-hours)",
       y = "VIIRS detections") +
  scale_x_continuous(labels = scales::comma) +
  scale_y_continuous(labels = scales::comma)
```


### Joined dataset

The final dataset we use for our analysis is a combination of the gridded AIS-based fishing effort data, the gridded SST data, and the gridded VIIRS detections. We inner join the AIS-based effort and SST datasets by `r spatial_resolution`x`r spatial_resolution` degree pixel and month, since both datasets cover the entire time series. We then left join the VIIRS detection dataset by pixel and month, since this dataset only covers January 2017 through December 2021. Note that the joined dataset does not contain flag-pixel-months with zero AIS-based fishing effort (i.e., the data are conditional on there being some effort for any given flag-pixel-month). If desired, once we have a spatial scope with which to restrict the analysis, we could construct a dataset for that bounding box that includes zero fishing effort flag-pixel-month rows.  

The joined dataset can be loaded in R using the command `targets::tar_load(joined_dataset)`. The dataset has the following colums:

* **month**: Month (first day of month) (date)  
* **lon_bin**:  `r spatial_resolution` degree longitude bin (degrees) (numeric)  
* **lat_bin**:  `r spatial_resolution` degree latitude bin (degrees) (numeric)  * **flag**:  Fishing flag (character)  
* **mean_sst**: Mean sea surface temperature, aggregated from the raw daily 0.25x0.25 degree data (degrees C) (numeric) 
* **sd_sst**: Standard deviation of sea surface temperature, aggregated from the raw daily 0.25x0.25 degree data (degrees C) (numeric) 
* **min_sst**: Minimum sea surface temperature (degrees C), aggregated from the raw daily 0.25x0.25 degree data (numeric) 
* **max_sst**: Maximum sea surface temperature (degrees C), aggregated from the raw daily 0.25x0.25 degree data (numeric) 
* **fishing_hours**:  Total fishing effort across vessels (hours) (numeric)  
* **fishing_kw_hours**:  Total fishing effort across vessels (kW-hours) (numeric)  
* **viirs_detections**: Night light detections from the VIIRS dataset (numeric)

Here we summarize these data (@tbl-summary-stats):

```{r}
#| label: tbl-summary-stats
#| tbl-cap: Summary statistics for joined dataset that includes, gridded SST, AIS-based fishing effort, and VIIRS detections

joined_dataset_summary
```